package main

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	"flag"
	"fmt"
	yaml "gopkg.in/yaml.v2"
	"io"
	"io/ioutil"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"
)

func GetSessionID(url, poststr, authorization string) (str string) {
	var jsonStr = []byte(poststr)
	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonStr))
	// req.Header.Set("X-Custom-Header", "myvalue")
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
	req.Header.Set("Authorization", authorization)
	//req.Header.Set("")

	client := &http.Client{
		Timeout: time.Duration(60 * time.Second), //超时
	}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	return resp.Header["X-Transmission-Session-Id"][0]
}

func GetDownloadlist(url, poststr, authorization string) (str string) {
	var jsonStr = []byte(poststr)
	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonStr))
	// req.Header.Set("X-Custom-Header", "myvalue")
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
	req.Header.Set("Authorization", authorization)
	req.Header.Set("X-Transmission-Session-Id", GetSessionID(url, poststr, authorization))

	client := &http.Client{
		Timeout: time.Duration(60 * time.Second), //超时
	}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	body, _ := ioutil.ReadAll(resp.Body)
	return string(body)
}

func newfileUploadRequest(uri string, params map[string]string, paramName, path string) (*http.Request, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)
	part, err := writer.CreateFormFile(paramName, path)
	if err != nil {
		return nil, err
	}
	// 这里的io.Copy实现,会把file文件都读取到内存里面，然后当做一个buffer传给NewRequest. 对于大文件来说会占用很多内存
	_, err = io.Copy(part, file)

	for key, val := range params {
		_ = writer.WriteField(key, val)
	}
	err = writer.Close()
	if err != nil {
		return nil, err
	}
	request, err := http.NewRequest("POST", uri, body)
	request.Header.Set("Content-Type", writer.FormDataContentType())
	return request, err
}

func postDateRequest(uri string, params map[string]string) (string, error) {

	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	//参数
	for key, val := range params {
		_ = writer.WriteField(key, val)
	}
	err := writer.Close()
	if err != nil {
		return "2222", err
	}
	request, err := http.NewRequest("POST", uri, body)
	request.Header.Set("Content-Type", writer.FormDataContentType())
	//return request, err
	client := &http.Client{
		Timeout: time.Duration(60 * time.Second), //超时
	}
	resp, err := client.Do(request)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()

	b, _ := ioutil.ReadAll(resp.Body)
	//fmt.Println("response Body:", string(body))
	return string(b), err
}

type TorrentGet struct {
	Arguments struct {
		Torrents []struct {
			DownloadDir string `json:"downloadDir"`
			HashString  string `json:"hashString"`
			ID          int    `json:"id"`
			Name        string `json:"name"`
			Status      int    `json:"status"`
		} `json:"torrents"`
	} `json:"arguments"`
	Result string `json:"result"`
}

type PostClients0 struct {
	Clients0 []string `json:"clients_0"`
}
type AppApiHash struct {
	Ret  int `json:"ret"`
	Data []struct {
		Hash    string `json:"hash"`
		Torrent []struct {
			Sid       int    `json:"sid"`
			TorrentID int    `json:"torrent_id"`
			InfoHash  string `json:"info_hash"`
		} `json:"torrent"`
	} `json:"data"`
	Msg     string `json:"msg"`
	Version string `json:"version"`
}
type AutoGenerated struct {
	Ret  int `json:"ret"`
	Data []struct {
		Client  string `json:"client"`
		Hash    string `json:"hash"`
		Torrent []struct {
			Sid       int    `json:"sid"`
			TorrentID int    `json:"torrent_id"`
			InfoHash  string `json:"info_hash"`
		} `json:"torrent"`
	} `json:"data"`
	Sites []struct {
		ID           int    `json:"id"`
		Site         string `json:"site"`
		BaseURL      string `json:"base_url"`
		DownloadPage string `json:"download_page"`
	} `json:"sites"`
	Errmsg  string `json:"errmsg"`
	Version string `json:"version"`
}

type ApiSitesInfo struct {
	Ret  int `json:"ret"`
	Data struct {
		Sites []struct {
			ID           int    `json:"id"`
			Site         string `json:"site"`
			BaseURL      string `json:"base_url"`
			DownloadPage string `json:"download_page"`
			IsHTTPS      int    `json:"is_https"`
		} `json:"sites"`
	} `json:"data"`
	Msg     string `json:"msg"`
	Version string `json:"version"`
}
type IyuuConf struct {
	IyuuToken string   `yaml:"iyuutoken"`
	Clients   []Client `yaml:"clients"`
	Sites     []Site   `yaml:"sites"`
}
type Client struct {
	Isuse    bool   `yaml:"isuse"`
	Type     string `yaml:"type"`
	Host     string `yaml:"host"`
	Username string `yaml:"username"`
	Password string `yaml:"password"`
}
type Site struct {
	Name    string `yaml:"name"`
	Ipv6    bool   `yaml:"ipv6"`
	Cookie  string `yaml:"cookie"`
	Passkey string `yaml:"passkey"`
}

type AddTorrentRespond struct {
	Arguments struct {
		Status  string `json:"status"`
		Torrent struct {
			HashString string `json:"hashString"`
			ID         int    `json:"id"`
			Name       string `json:"name"`
		} `json:"torrent"`
	} `json:"arguments"`
	Result string `json:"result"`
}

func GetPostHashDate(url, authorization string) (v TorrentGet, data []byte) {
	post := "{\"method\":\"torrent-get\",\"arguments\":{\"fields\":[\"id\",\"status\",\"name\",\"hashString\",\"downloadDir\"]},\"tag\":\"\"}"
	str := GetDownloadlist(url, post, authorization)
	pv := PostClients0{}
	//s:=make([]string, 0)
	err := json.Unmarshal([]byte(str), &v)
	if err == nil {
		for _, val := range v.Arguments.Torrents {
			if val.Status == 6 { //正在做种   0 暂停 6 正在做种 4 下载中
				//s = append(s, val.HashString)
				pv.Clients0 = append(pv.Clients0, val.HashString)
				//fmt.Println(val.HashString,val.Name)
			}

		}
	}
	//pv.Clients0=s
	//pv  pv.Clients0
	data, _ = json.Marshal(pv.Clients0)
	//fmt.Println(string(data))
	return
}
func GetApiHash(sign string, data []byte) (apiHash AppApiHash, err error) {
	timestamp := "123455678"
	version := "1.0.0"

	apiUrl := "http://api.iyuu.cn/?service=App.Api.Hash"

	postData := map[string]string{
		"sign":      sign,
		"timestamp": timestamp,
		"version":   version,
		"hash":      string(data),
	}
	r, err := postDateRequest(apiUrl, postData)
	if err == nil {

		if err := json.Unmarshal([]byte(r), &apiHash); err != nil {
			log.Fatal(err)
		}
	}
	return
}
func GetLoginAuthorization(login, password string) (authorization string) {
	authBytes := []byte(login + ":" + password)
	encodeAuth := base64.StdEncoding.EncodeToString(authBytes)
	authorization = fmt.Sprintf("Basic %s", encodeAuth)
	return
}
func GetSitesInfo(sign string) (sitesInfo ApiSitesInfo, err error) {
	siteUrl := "http://api.iyuu.cn/?service=App.Api.Sites&sign=" + sign
	postSiteData := map[string]string{
		"sign": sign,
	}
	rr, err := postDateRequest(siteUrl, postSiteData)
	if err == nil {
		if err := json.Unmarshal([]byte(rr), &sitesInfo); err != nil {
			log.Fatal(err)
		}
	}
	return
}
func (c *IyuuConf) getConf(path string) *IyuuConf {
	yamlFile, err := ioutil.ReadFile(path)
	if err != nil {
		fmt.Println(err.Error())
	}
	err = yaml.Unmarshal(yamlFile, c)
	if err != nil {
		fmt.Println(err.Error())
	}
	return c
}
func getTorrentUrl(site, downurl, passkey string, ipv6 bool) (url string) {
	switch site {
	case "ttg":
		url = downurl + "/" + passkey
	case "m-team", "moecat":
		if ipv6 { //true ipv6
			url = downurl + "&passkey=" + passkey + "&ipv6=1" + "&https=1"
		} else {
			url = downurl + "&passkey=" + passkey + "&https=1"
		}
	case "ccfbits":
		url = strings.Replace(downurl, "{passkey}", passkey, -1)
	default:
		url = downurl + "&passkey=" + passkey
	}
	return
}
func AddToTransmissionDownload(url, torrentUrl, downloadDir, authorization string) (v AddTorrentRespond, err error) {
	poststr := "{\"method\":\"torrent-add\",\"arguments\":{\"filename\":\"" + torrentUrl + "\",\"paused\":true,\"download-dir\":\"" + downloadDir + "\"},\"tag\":\"\"}"
	body := GetDownloadlist(url, poststr, authorization)

	str := strings.Replace(body, "\"torrent-duplicate\"", "\"status\":\"torrent-duplicate\",\"torrent\"", -1)
	str = strings.Replace(str, "\"torrent-added\"", "\"status\":\"torrent-added\",\"torrent\"", -1)
	//fmt.Printf(str)
	err = json.Unmarshal([]byte(str), &v)
	return
}

//
func main() {
	//读取配置文件
	var confPath string
	//flag.Parse()
	flag.StringVar(&confPath, "c", "./iyuu.yaml", "配置文件的路径。默认为路径为当前文件夹下iyuu.yaml")
	flag.Parse() //解析命令行参数
	//flag.PrintDefaults()    //输出帮助信息
	var c IyuuConf
	conf := c.getConf(confPath)
	//fmt.Println(conf.IyuuToken)
	for _, client := range conf.Clients {
		//fmt.Println(client.Password,client.Isuse)
		if client.Isuse == true { //下载器
			switch client.Type {
			//transmission
			case "transmission":
				url := client.Host
				authorization := GetLoginAuthorization(client.Username, client.Password)
				//获取 软件上正在做种 hashlist
				v, data := GetPostHashDate(url, authorization)
				//获取 apiHash
				apiInfo, err := GetApiHash(conf.IyuuToken, data)
				if err != nil {
					fmt.Println("api 访问故障！")
					break
				}
				sitesInfo, err := GetSitesInfo(conf.IyuuToken)
				if err != nil {
					fmt.Println("api 访问故障")
					break
				}
				for _, data := range apiInfo.Data {
					for _, torrent := range data.Torrent {
						for _, site := range sitesInfo.Data.Sites {
							if torrent.Sid == site.ID {
								for _, pa := range conf.Sites {
									if pa.Name == site.Site {
										if pa.Passkey != "" {
											for _, dt := range v.Arguments.Torrents {
												if dt.HashString == data.Hash {
													//fmt.Println(pa.Name,site.BaseURL,site.DownloadPage, torrent.TorrentID,pa.Passkey)
													var strHttp string
													if site.IsHTTPS == 1 {
														strHttp = "https://"

													} else if site.IsHTTPS == 0 {
														strHttp = "http://"
													}
													downloadDir := dt.DownloadDir
													torrentUrl := getTorrentUrl(site.Site, strHttp+site.BaseURL+"/"+strings.Replace(site.DownloadPage, "{}", strconv.Itoa(torrent.TorrentID), -1), pa.Passkey, pa.Ipv6)
													v, err := AddToTransmissionDownload(url, torrentUrl, downloadDir, authorization)
													if err == nil {
														switch v.Arguments.Status {
														case "torrent-duplicate":
															fmt.Printf("%s 添加下载：%s 重复，请检查种子是否暂停\n", site.Site, v.Arguments.Torrent.Name)
														case "torrent-added":
															fmt.Printf("%s 新添加下载：%s  状态：%s \n", site.Site, v.Arguments.Torrent.Name, v.Result)
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	fmt.Printf("程序执行完毕。。。")
}
